 #### 01.以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空
 ```
 static String str0="0123456789";
 static String str1="0123456789";
 String str2=str1.substring(5);
 String str3=new String(str2);
 String str4=new String(str3.toCharArray());
 str0=null;
 
 假定str0,...,str4后序代码都是只读引用。
 Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）
 
 A. 5
 B. 10
 C. 15
 D. 20
 
 正解：C
 解析：主要存储结构信息的地方，比如方法体，同时也是存储静态变量，
      以及静态代码块的区域，构造函数，常量池，接口初始化等等 
      方法区物理上还是在堆中，是在堆的持久代里面。
      堆有年轻代 (由一个Eden区和俩个survivor区组成)，老年代，
      持久代。新创建的对象都在年轻代的Eden区，经过一次JC收集后，
      存活下来的会被复制到survivor区(一个满了，就全部移动到另外一个大的中，
      但要保证其中一个survivor为空)，经过多次JC后，
      还存活的对象就被移到老年代了。 
      持久代就是经常说的方法区里面存放类信息，常量池，方法等 
      static String str0="0123456789"; 
      static String str1="0123456789";是放在方法区里。
      也就是持久代，题目中已经说了，不包含持久代，所以剩余空间为5+5+5=15.
 ```
 
#### 02. 其最小内存值和Survivor区总大小分别是（）
```
对于JVM内存配置参数：
-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3
,其最小内存值和Survivor区总大小分别是（）

A. 5120m，1024m
B. 5120m，2048m
C. 10240m，1024m
D. 10240m，2048m

正解 D
解析：-Xmx10240m：代表最大堆
     -Xms10240m：代表最小堆
     -Xmn5120m：代表新生代
     -XXSurvivorRatio=3：代表Eden:Survivor = 3    根据Generation-Collection算法(目前大部分JVM采用的算法)，一般根据对象的生存周期将堆内存分为若干不同的区域，一般情况将新生代分为Eden ，两块Survivor；    计算Survivor大小， Eden:Survivor = 3，总大小为5120,3x+x+x=5120  x=1024
      新生代大部分要回收，采用Copying算法，快！
      老年代 大部分不需要回收，采用Mark-Compact算法
```

#### 03.下面有关java类加载器，说法正确的是？
```
A. 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的
B. 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。
C. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类
D. tomcat为每个App创建一个Loader，里面保存着此WebApp的ClassLoader。需要加载WebApp下的类时，就取出ClassLoader来使用

正解：ABCD

解析：bootstrap classloader －引导（也称为原始）类加载器，
     它负责加载Java的核心类。 extension classloader －扩展类加载器，
     它负责加载JRE的扩展目录（JAVA_HOME/jre/lib/ext或者由java.ext.dirs系统属性指定的）中JAR的类包。 
     system classloader －系统（也称为应用）类加载器，它负责在JVM被启动时，加载来自在命令java中的-classpath或者java.class.path系统属性
     或者 CLASSPATH*作系统属性所指定的JAR类包和类路径。
```

#### 04. jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些
```
A. 栈空间满
B. 年轻代空间满
C. 老年代满
D. 持久代满
E. System.gc()

正解：CDE
解析：ull GC触发的条件
   除直接调用System.gc外，触发Full GC执行的情况有如下四种。
   1. 旧生代空间不足
   旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：
   java.lang.OutOfMemoryError: Java heap space 
   为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
   2. Permanet Generation空间满
   PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：
   java.lang.OutOfMemoryError: PermGen space 
   为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。
   3. CMS GC时出现promotion failed和concurrent mode failure
   对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。
   promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。
   应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。
   4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间
   这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。
   例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。
   当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。
   除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。
```

#### 05. 方法通常存储在进程中的哪一区（）
```
A. 堆区
B. 栈区
C. 全局区
D. 代码区
正解：D
解析：Java运行时的数据区包括：（其中前两个是线程共享的）
   1.方法区（Method Area） 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
   2.堆（Heap） 存放对象实例，几乎所有对象实例都在这里分配内存
   3.虚拟机栈（VM Stack） 描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个Stack Frame（方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态连接、方法出口等信息
   4.本地方法栈（Native Method Stack）  与虚拟机栈了类似，不过则为虚拟机使用的到的Native方法服务。（有的虚拟机譬如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一）
   5.程序计数器（Program Counter Register） 可看作当前线程所执行的字节码的行号的标识器
```

#### 06. 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？
```
吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。
```

#### 07. Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?
```
JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。
堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。
```

#### 08. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？
```
垃圾回收器(garbage colector)决定回收某对象时，
就会运行该对象的finalize()方法 但是在Java中很不幸，
如果内存总是充足的，那么垃圾回收可能永远不会进行，
也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 
那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。
Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。
但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），
finalize()的工作就是回收这部分的内存。
```

#### 09. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
```
不会，在下一个垃圾回收周期中，这个对象将是可被回收的。
```

#### 10.System.gc()和Runtime.gc()会做什么事情？
```
这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。
```

#### 11. 在Java中，对象什么时候可以被垃圾回收？
```
当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。
```

#### 12. JVM的永久代中会发生垃圾回收么？
```
垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区
(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)
```

#### 13. Java垃圾回收机制和常见算法
```
Sun公司只定义了垃圾回收机制规则而不局限于其实现算法，因此不同厂商生产的虚拟机采用的算法也不尽相同。
GC（Garbage Collector）在回收对象前首先必须发现那些无用的对象，如何去发现定位这些无用的对象？通常的搜素算法如下：
（1）引用计数器算法（废弃）
引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计算器-1，当计数器为0的时候，JVM就认为对象不再被使用，是“垃圾”了。
引用计数器实现简单，效率高；但是不能解决循环引用问题（A对象引用B对象，B对象引用A对象，但是A，B对象已不再被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在JDK1.1之后，这个算法就不再使用了。
（2）根搜索算法（使用）
根搜素算法是通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（Reference Chain），当一个对象没有被GC Roots的引用链连接的时候，说明这个对象是不可用的。
GC Roots对象包括：
a.虚拟机栈（栈帧中的本地变量表）中的引用的对象。
b.方法区域中的类静态属性引用的对象。
c.方法区域中常量引用的对象。
d.本地方法栈中JNI（Native方法）的引用的对象。
通过上面的算法搜索到无用对象之后，就是回收过程，回收算法如下：
（1）标记-清除算法（Mark-Sweep）（DVM使用的算法）
标记-清除算法包括连个阶段：“标记”和“清除”。在标记阶段，确定所有要回收的对象，并做标记。清除阶段紧随标记阶段，将标记阶段确定不可用的对象清除。标记-清除算法是基础的收集算法，标记和清除阶段的效率不高，而且清楚后回产生大量的不连续空间，这样当程序需要分配大内存对象时，可能无法找到足够的连续空间。
（2）复制算法（Copying）
复制算法是把内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候，把存活的对象复制到另一块上，然后把这块内存整个清理掉。复制算法实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率不高。现在的JVM用复制方法收集新生代，由于新生代中大部分对象（98%）都是朝生夕死的，所以两块内存的比例不是1:1（大概是8:1）。
（3）标记-整理算法（Mark-Compact）
标记-整理算法和标记-清除算法一样，但是标记-整理算法不是把存活对象复制到另一块内存，而是把存活对象往内存的一端移动，然后直接回收边界以外的内存。标记-整理算法提高了内存的利用率，并且它适合在收集对象存活时间较长的老年代。
（4）分代收集（Generational Collection）
分代收集是根据对象的存活时间把内存分为新生代和老生代，根据各个代对象的存活特点，每个代采用不同的垃圾回收算法。新生代采用复制算法，老生代采用标记-整理算法。垃圾算法的实现涉及大量的程序细节，而且不同的虚拟机平台实现的方法也各不相同。
```

#### 14. java内存模型
```
Java虚拟机将其管辖的内存大致分三个逻辑部分：方法区（Method Area）、Java栈和Java堆。
a.方法区是静态分配的，编译器将变量绑定在某个存储位置上，而且这些绑定不会再运行时改变。常数池，源代码中的命名常量、String常量和static变量保存在方法区。
b.Java Stack是一个逻辑概念，特点是后进先出。一个栈的空间可能是连续的，也可能是不连续的。最典型的Stack应用是方法的调用，Java虚拟机每调用一次方法就创建一个方法帧（frame），退出该方法则对应的方法帧被弹出（pop）。栈中存储的数据也是运行时确定的。
c.Java堆分配（heap allocation）意味着以随意的顺序，在运行时进行存储空间分配和回收的内存管理模型。堆中存储的数据常常是大小、数量和生命期在编译时无法确定的。Java对象的内存总是在heap中分配。
```

#### 15. Java内存分配
```
a.基础数据类型直接在栈空间分配。
b.方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收。
c.引用数据类型，需要用new来创建，即在栈空间分配一个地址空间，又在堆空间分配对象的类变量。
d.方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完后从栈空间回收。
e.局部变量new出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立即被回收，堆空间区域等待GC回收。
f.方法调用时传入的实际参数，现在栈空间分配，在方法调用完成后从栈空间释放。
g.字符串常量在DATA区域分配，this在堆空间分配。
h.数组即在栈空间分配数组名称，又在堆空间分配数组实际的大小。
```

#### 16. Java中引用类型都有哪些？
```
Java中对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。
（1）强引用
如果一个对象被人拥有强引用，那么垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象阿里解决内存不足问题。
Java的对象是位于heap中的，heap中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到达对象。应用的强弱顺序是强、软、弱和虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。
String abc = new String(“abc”);//强引用，abc为强可及
SoftReference<String> softRef = new SoftReference<String>(abc);//软引用
WeakReference<String> weakRef = new WeakReference<String>(abc);//弱引用
abc=null;//abc软可及
softRef.clear();//abc变成弱可及
（2）软引用
如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
软引用主要用于内存敏感的高速缓存。在jvm报告内存不足之前会清除所有的软引用，这样以来gc就有可能手机软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于gc的算法和gc运行时可用内存的大小。当gc决定要收集软引用时执行步骤如下：（以上面的softRef为例）
a.首先将softRef的referent(abc)设置为null，不再引用heap中的new String(“abc”)对象。
b.将heap中的new String(“abc”)对象设置为可结束的（finalizable）。
c.当heap中的new String(“abc”)对象的finalize()方法被运行而且该对象占用的内存被释放，softRef被添加到它的ReferenceQueue（如果有的话）中。
注意：对ReferenceQueue软引用和弱引用可有可无，但虚引用必须有。
被Soft Reference指到的对象，即使没有任何Direct Reference，也不会被清除。一直要到JVM内存不足且没有Direct Reference时才会清除，SoftReference是用来设计objct-cache之用的。如此一来SoftReference不但可以把对象cache起来，也不会造成内存不足的错误（OutOfMemoryError）。
（3）弱引用
如果一个对象只具有弱引用，那该类就是可有可无的对象，因为只要该对象被gc扫描到随时都会把它干掉。
弱引用和软引用的区别：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现只具有弱引用的对象。
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象呗垃圾回收器回收，Java虚拟机就会把这个弱引用加到与之关联的引用队列中。
（4）虚引用
“虚引用”与其他集中引用不同，虚引用并不决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。
虚引用与软引用和弱引用的区别：虚引用必须和引用队列（ReferneceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还是虚引用，就会在回收对象的内存之前，把这个虚引用假如到与之关联的引用队列中。程序可以通过判断引用队列中是否加入了虚引用。来了解被引用的对象是否要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在引用的对象的内存被回收之前采用必要的行动。
建立虚引用之后通过get方法返回结果始终为null，通过源代码会发现，虚引用通常会把引用的对象写进referent，只是get方法返回结果为null。和gc交互的过程：a.不把referent设置为null，直接把heap中的new String(“abc”)对象设置为可结束的（finalizable）。b.与软引用和弱引用不同，先把PhantomReference对象添加到它的ReferencQueue中，然后在释放虚可及的对象。
```

#### 17. Java的类加载器的种类都有哪些？
```
（1）根类加载器（Bootstrap）---C++写的，看不到源码
（2）扩展类加载器（Extension）---加载位置：jre\lib\ext中
（3）系统（应用）类加载器（System\App）---加载位置：classpath中
（4）自定义加载器（必须继承ClassLoader）
```

#### 18. 类什么时候被初始化？
```
（1）创建类的实例，也就是new一个对象。
（2）访问某个类或接口的静态变量，或者对该静态变量赋值。
（3）调用类的静态方法。
（4）反射。
（5）初始化一个类的子类。
（6）JVM启动时标明的启动类，即文件名和类名相同的那个类。
只有这6种情况才会导致类的初始化。
```

#### 19. 类的初始化步骤
```
（1）如果这个类还没有被加载和链接，那先进行加载和链接。
（2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类智能初始化一次），那就初始化直接的父类（不适用于接口）。
（3）假如类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。
```

## 来源或参考：
   - 牛客网
   - http://www.cnblogs.com/zhangmiao14/p/6385854.html?utm_source=tuicool&utm_medium=referral